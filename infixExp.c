/* prefixExp.c, Gerard Renardel, 29 January 2014
 *
 * In this file functions are defined for the construction of expression trees
 * from prefix expressions generated by the following BNF grammar:
 *
 * <prefexp>   ::= <number> | <identifier> | '+' <prefexp> <prefexp>
 *             | '-' <prefexp> <prefexp> | '*' <prefexp> <prefexp> | '/' <prefexp> <prefexp>
 *
 * <number>      ::= <digit> { <digit> }
 *
 * <identifier> ::= <letter> { <letter> | <digit> }
 *
 * Starting pount is the token list obtained from the scanner (in scanner.c).
 */

#include <stdio.h>  /* printf */
#include <stdlib.h> /* malloc, free */
#include <assert.h> /* assert */
#include "scanner.h"
#include "recognizeExp.h"
#include "evalExp.h"
#include "prefixExp.h"
#include "infixExp.h"

typedef struct stack {
	List *array;
	int size;
	int count;
} Stack;

void stackMemoryFailure(int size){
	printf("Failed to allocate a stack of size %i.\n", size);
	exit(EXIT_FAILURE);
}
Stack *createStack(int initialSize) {
	Stack *output = malloc(sizeof(Stack));
  //printf("Stack allocation succesfull\n");
	if (initialSize <= 0 || output == NULL) {
		stackMemoryFailure(initialSize);
	}
	output->count = 0;
	output->size = initialSize;
	output->array = malloc(initialSize * sizeof(List));
  //printf("Stack  node array allocation succesfull\n");
	return output;
}
void freeStack(Stack *st) {
	free(st->array);
	free(st);
}
List pop(Stack *st) {
	if (st->count <= 0) {
		printf("Stack empty: pop failed.\n");
		exit(EXIT_FAILURE);
	}
	(st->count)--;
  //printf("count decreased = %d\n", st->count);
  printf("popped item = %c\n",st->array[st->count]->t.symbol);
	return st->array[st->count];
}
void expandStack(Stack *st) {
	st->size *= 2;
	st->array = realloc(st->array, st->size * sizeof(List));
	if (st->array == NULL) {
		stackMemoryFailure(st->size);
	}
}
void push(List item, Stack *st) {
	while (st->size <= st->count) {
		expandStack(st);
	}
	st->array[st->count] = item;
	(st->count)++;
  //printf("count = %d\n", (st)->count);
}
int isStackEmpty(Stack *st) {
	return ((st->count) <= 0);
}

List reverseTokenLists(List lp){
  if(lp == NULL){
    return NULL;
  }
  if (lp->next == NULL)
  {
    return lp;
  }
  List node1 = malloc(sizeof(ListNode));
  assert(node1 != NULL);
  node1 = reverseTokenLists(lp->next);
  lp->next->next = lp;
  lp->next = NULL;
  return node1;

}

List infixToPrefix (List li){
  li = reverseTokenLists(li);
  //printf("Initiate conversion to prefix\n");
  List expressionList = NULL, node = NULL, endNode = NULL;
  Stack *operatorStack = createStack(10);
  //printf("Memory allocation succesfull: OperatorStack created\n");
  while(li != NULL){
    //if operand
    if(li->tt == Identifier || li->tt == Number){
      node = li;
      li = li->next;
      node->next = NULL;
      if(expressionList == NULL){
        expressionList = node;
      }else{
        endNode->next = node;
      }
      endNode = node;
      continue;
    }
    //if * or /
    else if (li->tt == Symbol && (li->t.symbol == '*' || li->t.symbol == '/')){
      push(li, operatorStack);
      li = li->next;
    }
    //if closing bracket
    else if(li->tt == Symbol && li->t.symbol == ')'){
      li = li->next;
      while(li != NULL && li->t.symbol != '(' ){
        //add all operators to operator stack
        if (li->t.symbol == '*' || li->t.symbol == '/' ||  li->t.symbol == '+' || li->t.symbol == '-'){
          push(li, operatorStack);
          //printf("%c\n", li->t.symbol);
          li = li->next;
        //add operands to expression
        }else if(li->tt == Identifier || li->tt == Number){
          node = li;
          li = li->next;
          node->next = NULL;
          if(expressionList == NULL){
            expressionList = node;
          }else{
            endNode->next = node;
          }
          endNode = node;
        }
      }
      //when '(' is encountered, pop everything to the expression until )
      while(operatorStack->count > 0 && (operatorStack->array[operatorStack->count - 1]->t.symbol != ')')){
        node = pop(operatorStack);
        node->next = NULL;
        if(expressionList == NULL){
          expressionList = node;
        }else{
          endNode->next = node;
        }
        endNode = node;
      }
      li = li->next;

    }
    //if - or +
    else if(li->tt == Symbol && (li->t.symbol == '-' || li->t.symbol == '+')){
      //printf("in if %c\n", li->t.symbol);
      //while top of stack is '*' or '/'
      while(operatorStack->count > 0 && (operatorStack->array[operatorStack->count - 1]->t.symbol == '*' || operatorStack->array[operatorStack->count - 1]->t.symbol == '/')){
        //printf("top of stack has higher priority than pushed item, popping higher priority items \n");
        node = pop(operatorStack);
        node->next = NULL;
        if(expressionList == NULL){
          expressionList = node;
        }else{
          endNode->next = node;
        }
        endNode = node;
      }
      push(li, operatorStack);
      li = li->next;
    }
  }
  //printf("classification into: 'Stack' and: 'ExpressionList' succesfull\n");
  //printList(expressionList);
  //pop entire stack to expression
  while(operatorStack->count > 0){
    node = pop(operatorStack);
    node->next = NULL;
    if(expressionList == NULL){
      expressionList = node;
    }else{
      endNode->next = node;
    }
    endNode = node;
  }
  return reverseTokenLists(expressionList);
}


int treeInfixExpression(List *lp, ExpTree *tp) {
  double w;
  char *s;
  char c;
  Token t;
  ExpTree tL, tR;
  if ( valueNumber(lp,&w) ) {
    t.number = (int)w;
    *tp = newExpTreeNode(Number, t, NULL, NULL);
    return 1;
  }
  if ( valueIdentifier(lp,&s) ) {
    t.identifier = s;
    *tp = newExpTreeNode(Identifier, t, NULL, NULL);
    return 1;
  }
  if ( valueOperator(lp,&c) && treeInfixExpression(lp,&tL) ) {
    if ( treeInfixExpression(lp,&tR) ) {
      t.symbol = c;
      *tp = newExpTreeNode(Symbol, t, tL, tR);
      return 1;
    } else { /* withuot 'else' the program works fine, but there is a memory leak */
      freeExpTree(tL);
      return 0;
    }
  }
  return 0;
}


void infixExpTrees() {
  char *ar;
  List tl, tl1;
  ExpTree t = NULL;
  printf("give an expression: ");
  ar = readInput();
  while (ar[0] != '!') {
    tl = tokenList(ar);
    printList(tl);
    List li = tl;
    if (!acceptExpression(&li)){
      printf("this is not an expression\n");
      freeExpTree(t);
      t = NULL;
      freeTokenList(tl);
      free(ar);
      printf("\ngive an expression: ");
      ar = readInput();
      continue;
    }
    tl = infixToPrefix(tl);
    tl1 = tl;

    if ( treePrefixExpression(&tl1,&t) && tl1 == NULL ) {
         /* there should be no tokens left */
      printf("in infix notation: ");
      printExpTreeInfix(t);
      printf("\n");
      if ( isNumerical(t) ) {
        printf("the value is %g\n",valueExpTree(t));
      } else {
        printf("this is not a numerical expression\n");
      }
    } else {
      printf("this is not an expression\n");
    }
    freeExpTree(t);
    t = NULL;
    freeTokenList(tl);
    free(ar);
    printf("\ngive an expression: ");
    ar = readInput();
  }
  free(ar);
  printf("good bye\n");
}
